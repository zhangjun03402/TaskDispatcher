
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <process.h>
#include "hasp_api.h"
#include "lic.h"
#include <glog\logging.h>

using namespace Lingban::CoreLib;
//using namespace Lingban::Common;

const char* LINGBAN_LIC_VERIFICATION = "709E0BDD-B87C-43A1-BBDA-4252C2D9D272";

const int VENDOR_CODE_LEN = 984;
const unsigned char MAGIC = 173;

unsigned char CLicense::lingban_vendor_code[] = {
	0xf8, 0xf7, 0xe6, 0xc2, 0x99, 0xd7, 0x9d, 0x9f, 0xdf, 0xf8, 0x9c, 0x9a, 0xce, 0xfb, 0xdc, 0xe3,
	0xce, 0xeb, 0xf7, 0xff, 0xe7, 0xea, 0xef, 0xfd, 0xc3, 0x9d, 0xec, 0xd8, 0xff, 0xec, 0xc5, 0xf8,
	0xea, 0xf8, 0xde, 0xdf, 0x9f, 0x9a, 0x82, 0xf4, 0xec, 0xf9, 0xc6, 0xfd, 0xda, 0xd7, 0xf7, 0xd4,
	0xcc, 0xe8, 0xc4, 0x9f, 0xc7, 0xcb, 0xca, 0xf7, 0xf8, 0xfb, 0x9b, 0xce, 0xeb, 0xc5, 0x98, 0xe8,
	0xda, 0xc9, 0xfc, 0xdd, 0xc7, 0xf7, 0xdd, 0xd7, 0xef, 0xc7, 0x9f, 0xcc, 0xeb, 0x95, 0xfd, 0xc9,
	0xc1, 0xe7, 0xdc, 0x94, 0xf9, 0xc7, 0xec, 0x99, 0x9c, 0xe3, 0xef, 0xec, 0xfe, 0xfe, 0xfe, 0xce,
	0xe6, 0xff, 0xfe, 0xc2, 0xcc, 0xea, 0x95, 0xd5, 0xe5, 0xcb, 0x9b, 0xf5, 0xe1, 0x9b, 0xfa, 0xc8,
	0x9a, 0xf4, 0xfe, 0xef, 0xf8, 0xde, 0x86, 0xcc, 0xde, 0xce, 0xd7, 0xff, 0x9b, 0xf9, 0x99, 0xf7,
	0xd5, 0xe3, 0x82, 0x9a, 0xe4, 0xe7, 0xc9, 0xcb, 0xe9, 0xc9, 0xdf, 0xc2, 0xe4, 0xd5, 0xee, 0xc1,
	0xe9, 0xec, 0xe8, 0x9e, 0xc7, 0xdf, 0x95, 0xd4, 0xc8, 0xca, 0x94, 0xec, 0x9b, 0xc2, 0xe4, 0xee,
	0xf7, 0xfc, 0xdb, 0xdd, 0xe2, 0xfe, 0x95, 0xc7, 0xe5, 0xda, 0xce, 0xf4, 0xd8, 0xc5, 0x99, 0xef,
	0xfe, 0xc5, 0xff, 0x9f, 0xf9, 0xf4, 0xc2, 0xd5, 0xc2, 0xd7, 0x82, 0xda, 0xeb, 0xe5, 0xc3, 0xfd,
	0x86, 0xd8, 0xfc, 0x82, 0xe3, 0xdb, 0xc1, 0x9a, 0xc2, 0xd9, 0xce, 0xc6, 0xee, 0x9f, 0x9a, 0xf4,
	0xe5, 0xeb, 0xeb, 0xe3, 0xd7, 0xc0, 0x9a, 0xfe, 0xd5, 0xd4, 0xc8, 0x99, 0xc2, 0xf4, 0xe8, 0xfa,
	0x9a, 0xc6, 0xda, 0xe8, 0x9e, 0xd8, 0xd5, 0xe9, 0xc3, 0xfa, 0xc6, 0xe3, 0xc4, 0xdb, 0xd7, 0xfa,
	0xc9, 0xdd, 0x82, 0xcb, 0xe1, 0xf4, 0xf9, 0xff, 0xe7, 0xe9, 0x9b, 0x82, 0x95, 0xde, 0xc8, 0xc9,
	0xc3, 0xf4, 0xc4, 0xee, 0xcf, 0xc3, 0xd9, 0x94, 0xdc, 0x98, 0xc3, 0xd5, 0xdd, 0xc0, 0xc7, 0xe2,
	0xcc, 0xc2, 0x99, 0xdd, 0xde, 0xe2, 0xc6, 0xc8, 0xde, 0xe3, 0xe1, 0x9d, 0xf8, 0xfc, 0xe6, 0xfb,
	0x9d, 0xe9, 0x9d, 0xc2, 0xc1, 0xde, 0xc0, 0xec, 0xe0, 0xde, 0xd5, 0xeb, 0xdf, 0xe0, 0xde, 0xc9,
	0xef, 0xce, 0xfc, 0x98, 0xd4, 0xfa, 0x9a, 0x86, 0xcc, 0xcb, 0x99, 0xe9, 0xe0, 0xc4, 0xe9, 0xeb,
	0xcf, 0x9b, 0xc0, 0xee, 0xc8, 0xc9, 0xcb, 0xd7, 0xdd, 0xc0, 0xfa, 0x9d, 0xeb, 0xf4, 0xf9, 0xc6,
	0xec, 0xcb, 0x9f, 0xe5, 0x9d, 0x9f, 0xda, 0xfd, 0xdc, 0xde, 0xfb, 0x9d, 0xf4, 0xea, 0x9a, 0xdd,
	0xc3, 0x9b, 0xe7, 0xcc, 0xd9, 0x86, 0xc0, 0xe5, 0xfd, 0xdc, 0x9f, 0xe0, 0xe4, 0xfb, 0xeb, 0xef,
	0xc8, 0xf5, 0xd9, 0xc4, 0xc5, 0xf5, 0xc2, 0xea, 0xfa, 0xc3, 0xdb, 0xe8, 0xca, 0xef, 0xe9, 0xcf,
	0xe4, 0xc8, 0xfd, 0xe7, 0x9a, 0xc2, 0x95, 0xe2, 0xf9, 0xd5, 0xe0, 0xea, 0xfe, 0xd5, 0xfa, 0xdd,
	0xd8, 0xe1, 0xdf, 0xce, 0xd8, 0xe5, 0xdb, 0xda, 0xe3, 0xc7, 0xe2, 0xd8, 0xe6, 0x9d, 0xc3, 0x9e,
	0xd4, 0xd9, 0xea, 0xc5, 0xc6, 0xe1, 0xec, 0xf9, 0x9c, 0xdd, 0xfd, 0xe4, 0xe3, 0xc0, 0xc3, 0xce,
	0xc4, 0xf9, 0xe3, 0xdc, 0xd9, 0xda, 0xc4, 0x9a, 0xf4, 0xfa, 0xe2, 0xf8, 0xde, 0xe6, 0xe3, 0xff,
	0xf5, 0xde, 0x9c, 0xda, 0xfb, 0x95, 0xce, 0xf7, 0xec, 0x9d, 0xeb, 0xeb, 0x9e, 0xc1, 0xcf, 0x9d,
	0xc6, 0x82, 0xff, 0xf9, 0xf4, 0xdb, 0xfa, 0x9f, 0x86, 0xc1, 0x9b, 0xf4, 0xde, 0xe5, 0xe4, 0xd5,
	0xde, 0x98, 0xc9, 0xdb, 0xc1, 0x9c, 0xfa, 0x9f, 0xd4, 0xe2, 0xc3, 0xff, 0xfc, 0xe2, 0xfe, 0x9f,
	0xe2, 0xd9, 0xe7, 0xe4, 0xc3, 0xde, 0xd8, 0xdf, 0x86, 0xc8, 0x86, 0x99, 0xc7, 0xe9, 0x94, 0xe8,
	0x99, 0xc0, 0xdf, 0xd9, 0xc9, 0xe9, 0x9d, 0x95, 0x9f, 0xec, 0xc2, 0x82, 0xdb, 0xd8, 0xc2, 0xc5,
	0xd5, 0xfe, 0x95, 0xf4, 0xf5, 0xda, 0xc4, 0xe1, 0xd7, 0xe8, 0x86, 0xc6, 0x86, 0xc4, 0xdf, 0x9a,
	0xef, 0x9d, 0xfd, 0xe9, 0xe9, 0x94, 0xc7, 0xc9, 0xda, 0xe8, 0xf9, 0xf5, 0xdd, 0xff, 0xe9, 0xf7,
	0xc8, 0xeb, 0xc6, 0xf8, 0xc5, 0xe6, 0x95, 0xdc, 0xcb, 0xc4, 0xdb, 0xdb, 0xf4, 0xe5, 0xfd, 0xfa,
	0x9d, 0xe8, 0x9c, 0x98, 0xf9, 0xea, 0xce, 0xeb, 0xdc, 0x9d, 0xc3, 0xe4, 0x94, 0xff, 0xfa, 0xfd,
	0x9e, 0xc7, 0xfd, 0xef, 0xcb, 0xe5, 0xd9, 0xf4, 0xc5, 0xeb, 0xec, 0xd7, 0xc5, 0xec, 0xef, 0xe4,
	0xc5, 0xf5, 0xfb, 0xde, 0x9d, 0xdf, 0xc2, 0xe8, 0xc3, 0x82, 0xd5, 0xe4, 0x9c, 0xe9, 0xdc, 0xdd,
	0xc6, 0x9b, 0xf4, 0xf8, 0xd5, 0xf4, 0x9b, 0x9e, 0xfd, 0xdc, 0xf9, 0xff, 0xd4, 0xdb, 0xc8, 0xe3,
	0xdc, 0xc4, 0xc8, 0xc4, 0xe3, 0xcc, 0xe1, 0xc8, 0x9f, 0xea, 0xc4, 0xe3, 0xe1, 0xcb, 0xdd, 0xfa,
	0xc3, 0xfe, 0xda, 0x98, 0x98, 0x99, 0xd8, 0xe4, 0x9f, 0xef, 0xc2, 0xff, 0xef, 0xff, 0xdb, 0xc4,
	0xe8, 0xde, 0xd8, 0x9d, 0xc7, 0xd5, 0xc5, 0xc9, 0x95, 0x99, 0xc2, 0xde, 0xe9, 0xdd, 0xdc, 0xf8,
	0x86, 0xfe, 0xe7, 0xc4, 0xe3, 0x9f, 0xdf, 0xfc, 0x9f, 0xc5, 0xe1, 0x98, 0xc3, 0x98, 0xf7, 0xc4,
	0xe2, 0xe3, 0xcc, 0xe7, 0xf8, 0xcf, 0xd5, 0xe7, 0x99, 0xdd, 0xc0, 0x9c, 0x9e, 0x95, 0xc8, 0xe1,
	0xc8, 0xd4, 0x99, 0xec, 0xe3, 0xff, 0xe6, 0xd7, 0xc7, 0xe7, 0xda, 0xec, 0xcb, 0x99, 0x9c, 0x94,
	0xd9, 0x82, 0xde, 0xca, 0xf8, 0xdf, 0xc6, 0xe5, 0xc5, 0xe3, 0xea, 0xda, 0x9d, 0xda, 0xff, 0xe1,
	0xdf, 0xcf, 0xe6, 0xdf, 0xe6, 0xda, 0x9d, 0xc8, 0xc7, 0xe7, 0xc9, 0xe5, 0xee, 0xe0, 0x9a, 0xe4,
	0xd8, 0xdf, 0xe1, 0xf8, 0xd8, 0xd7, 0xc4, 0xe3, 0xf4, 0xce, 0xe4, 0xda, 0xcf, 0xc1, 0xe9, 0xdb,
	0xee, 0xc0, 0xce, 0xd5, 0xfe, 0xf7, 0xcb, 0xcc, 0xfd, 0xdc, 0xd7, 0xcb, 0xca, 0xf9, 0xd4, 0xe3,
	0x9f, 0xfa, 0xf9, 0xf9, 0xee, 0xf8, 0xd4, 0xdf, 0xff, 0xc9, 0xec, 0xc5, 0xff, 0xe1, 0xd9, 0xc0,
	0xf5, 0x9d, 0x82, 0xde, 0xfa, 0x95, 0xfa, 0xe9, 0xdf, 0xc3, 0xcb, 0xca, 0xee, 0xdf, 0xfd, 0x9f,
	0xe7, 0xd5, 0xd7, 0xe2, 0xdd, 0xc4, 0xc8, 0xd4, 0xc6, 0xec, 0xc9, 0xc6, 0xe6, 0xda, 0xfa, 0xd5,
	0xe5, 0xda, 0xfd, 0xfd, 0xe7, 0x86, 0xe8, 0xc6, 0xf7, 0xc1, 0xe3, 0xe4, 0xe8, 0xfc, 0xfa, 0xdd,
	0xf7, 0xfb, 0xd4, 0xca, 0xf4, 0x9f, 0xfb, 0xf7, 0x9d, 0xfd, 0xe9, 0xe7, 0x9f, 0xc7, 0xfd, 0xe6,
	0xe8, 0xe1, 0x9f, 0xd8, 0xf7, 0xe8, 0xcb, 0xff, 0xe7, 0x9a, 0xc6, 0xec, 0xdc, 0xf4, 0xee, 0xec,
	0xee, 0xde, 0xc8, 0xfa, 0xc8, 0xe4, 0xef, 0x86, 0xcb, 0xc3, 0xe4, 0xc0, 0xcf, 0x86, 0xee, 0xd7,
	0xfa, 0xe0, 0x99, 0xd4, 0xea, 0xfb, 0xfd, 0xea, 0xc1, 0xe6, 0xc2, 0xfa, 0x95, 0xef, 0xd4, 0xef,
	0xcb, 0xc8, 0xc0, 0xe0, 0xeb, 0xef, 0x98, 0xf7, 0xd5, 0xee, 0xe7, 0xc4, 0xeb, 0xdc, 0x94, 0xfb,
	0xe0, 0xca, 0xc4, 0xef, 0xdc, 0x86, 0xcf, 0xd7, 0xff, 0xd7, 0xc3, 0xf9, 0x82, 0xc0, 0xc5, 0xc7,
	0xcb, 0x9d, 0xde, 0xcc, 0xc0, 0xf4, 0x98, 0xd7, 0xdf, 0xd9, 0xce, 0xdf, 0xe1, 0xff, 0x86, 0xe0,
	0x99, 0xc0, 0x9e, 0xd7, 0xf5, 0xca, 0x90, 0x90, 0x00
};

CLicense::CLicense()
{
	ready = false;
	feature_id = 0;
	n_permissions = 0;
	status = LIC_BROKEN;
	debug_mode = true;
	watch_dog_clock = clock();
	hasp_status = HASP_STATUS_OK;
	lic_handle = HASP_INVALID_HANDLE_VALUE;
	exiting = false;
	init_flag = false;
	enc_flag = false;	
}

CLicense & CLicense::GetInstance(){
	static CLicense Instance;
	return Instance;
}

void CLicense::VendercodeEncDenc()
{	
	for (int i = 0; i < VENDOR_CODE_LEN; i++){
		lingban_vendor_code[i] = lingban_vendor_code[i] ^ MAGIC;
	}
}

void * CLicense::ServiceRoutine()
{
	int i;
	bool isok = false;
	char *info = NULL;
	clock_t last_clk = 0;
	clock_t status_clk = 0;

	unsigned char term_reading_buffer[4];

	if (debug_mode)fprintf(stderr, "DEBUG: Maintaining thread started, license feature = %d, initial n_term= %d.\n",
		feature_id,
		n_permissions);

	//初始情况下handle应该为未赋值
	if (HASP_INVALID_HANDLE_VALUE != lic_handle){
		strcpy(error_string, "Try to relaunch running maintaining thread.\n");
		return NULL;
	}

	last_clk = clock();
	status_clk = last_clk;
	status = LIC_BROKEN;
	exiting = false;
	int  mem_offset = feature_id;

	while (!exiting){

		watch_dog_clock = clock();
		isok = false;
		if (debug_mode)fprintf(stderr, "DEBUG: Retrieve license status....\n");

		for (i = 0; i < 3; i++){
			if (lic_handle == HASP_INVALID_HANDLE_VALUE){
				hasp_status = hasp_login(feature_id, lingban_vendor_code, &lic_handle);
				if (hasp_status != HASP_STATUS_OK){
					lic_handle = HASP_INVALID_HANDLE_VALUE;
				} else{
					int r = hasp_read(lic_handle, HASP_FILEID_RO, mem_offset, 4, term_reading_buffer);
					int n_mem_term = term_reading_buffer[2] * 256 + term_reading_buffer[3];
					if (n_mem_term > 0){
						n_permissions = n_mem_term;
						LOG(INFO)<<"Number of permission retrieved from hasp memory, n_term ="<< n_permissions;						
					}
					isok = true;
					break;
				}
			} else{
				hasp_status = hasp_get_sessioninfo(lic_handle, HASP_SESSIONINFO, &info);
				if (hasp_status != HASP_STATUS_OK){
					lic_handle = HASP_INVALID_HANDLE_VALUE;
				} else{
					hasp_free(info);
					isok = true;
					break;
				}
			}
		}

		if (debug_mode)fprintf(stderr, "DEBUG: license is %s\n", isok ? "Ready." : "Not ready!");

		last_clk = clock();
		switch (status){
		case LIC_OK:
			if (!isok){
#ifndef DELAY_LOST
				status = LIC_LOST; //for delayable license attachment 
#else
				lic_state = LIC_BROKEN; //for delayable license attachment 
#endif
				status_clk = last_clk;
			}
			break;
		case LIC_LOST:
			if (isok){
				status = LIC_OK;
				status_clk = last_clk;
			}
			break;
		case LIC_BROKEN:
			if (isok){
				status = LIC_OK;
				status_clk = last_clk;
			} else if (last_clk - status_clk > (120 * CLOCKS_PER_SEC)){
				status = LIC_LOST;
				status_clk = last_clk;
			} else{
#ifndef DELAY_LOST
				status = LIC_LOST; //for delayable license attachment 
#else
				lic_state = LIC_BROKEN; //for delayable license attachment 
#endif
			}
		}

		int sleep_count = (status == LIC_OK) ? 120 : 3;
		sleep_count *= 20;
		int sleep_period = CLOCKS_PER_SEC / 20;

		for (i = 0; i < sleep_count; i++){
			if (exiting)
				break;

			std::this_thread::sleep_for(std::chrono::milliseconds(sleep_period));
			//Sleep(sleep_period);
		}
		

	}

	if (lic_handle != HASP_INVALID_HANDLE_VALUE){
		hasp_logout(lic_handle);
		lic_handle = HASP_INVALID_HANDLE_VALUE;
	}
	return 0;

}

int CLicense::Status(int *_hasp_status)
{
	if (_hasp_status)
		*_hasp_status = hasp_status;

	clock_t wclock = watch_dog_clock;
	if (false && clock() - wclock > 300 * CLOCKS_PER_SEC){
		if (debug_mode)fprintf(stderr, "DEBUG: Maintaining thread frozen, invoking failed....\n");
		sprintf(error_string, "The maintaining thread is frozen, function invoking failed.\n");
		return LIC_ATTACKED;
	} else{
		sprintf(error_string, "");
		return status;
	}

}

lic_result_t CLicense::Start(int _feature_id, int _n_permission)
{
	unsigned char term_reading_buffer[4];
	int max_try = 1000;
	sprintf(error_string, "");
	if (!enc_flag){
		VendercodeEncDenc();
		enc_flag = true;
	}

	if (!init_flag){
		feature_id = _feature_id;
		n_permissions = _n_permission;
		int mem_offset = _feature_id;		
		for (int trycnt = 0; trycnt < max_try; trycnt++){
			hasp_status = hasp_login(feature_id, lingban_vendor_code, &lic_handle);
			if (hasp_status != HASP_STATUS_OK){
				lic_handle = HASP_INVALID_HANDLE_VALUE;
				LOG(INFO)<< "Failed login license service, try #"<<trycnt;
				std::this_thread::sleep_for(std::chrono::seconds(1));
			} else{
				status = LIC_OK;
				this->watch_dog_clock = clock();
				int r = hasp_read(lic_handle, HASP_FILEID_RO, mem_offset, 4, term_reading_buffer);
				unsigned int n_mem_term = term_reading_buffer[2] *256 + term_reading_buffer[3];
				if (n_mem_term > 0){
					n_permissions = n_mem_term;
					LOG(INFO)<< "Number of permission retrieved from hasp memory, n_term = "<< n_permissions;
				}				
				init_flag = true;
				break;
			}
		}
		if (init_flag){
            th = std::thread(std::bind(&CLicense::ServiceRoutine, this));
		}				
	}
	return init_flag;
	
}


lic_result_t CLicense::Exit()
{
	//void *ret;
	if (init_flag){
		exiting = true;

		if (th.joinable())
			th.join();
		status = LIC_LOST;
		init_flag = false;
	}
	return 0;

}

void CLicense::SetDebugMode(bool mode)
{
	debug_mode = mode;
}


const std::string & CLicense::GetErrorMsg()
{
	return error_string;
}

int CLicense::GetHaspStatus()
{
	return hasp_status;
}

int CLicense::GetPermissionCount()
{
	return n_permissions;
}